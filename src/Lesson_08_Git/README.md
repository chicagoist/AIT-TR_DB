
git init
git add -A
git commit -m "first commit"
git branch -M main
git remote add origin git@github.com:chicagoist/lesson_08_git_valerii.git
git push -u origin main


Задачи на урок:

    Как создать репозиторий из готового кода?
        git remote add origin {url} - добавить удалённый репозиторий
    git revert, git reset - откат изменений
    Совместная работа - collaborators
    Разрешение конфликтов
        При слиянии веток (merge)
        При обновлении ветки (pull)
        При отправке пулл-реквеста
    Практика по группам

Зачем нужна система контроля версий?

Каждому из нас хотя бы раз в жизни при написании программы или редактировании текста было необходимо откатиться назад, например, потому, что вы случайно удалили важный параграф.

Хорошо, если это изменение, которое произошло только что — многие редакторы поддерживают отмену изменений, например, сочетанием клавиш Ctrl+Z.

Однако трудно обратить действия, если изменения произошли давно, а ошибка была обнаружена спустя какое-то время. В таком случае самое простое решение — раз в день создавать копию документа и помещать в другую папку, помечая ее датой, в которую эти изменения были созданы.

Это самое простое в реализации решение, однако при восстановлении легко ошибиться и перепутать папки. Ситуация еще больше усложняется, если над этим документом или кодом программы работают несколько человек, каждый из которых решает свои собственные задачи.

Система контроля версий предназначена для сохранения истории изменений.

История представляет собой снимки проекта, следующие друг за другом в хронологическом порядке. В любой момент можно откатиться к любому состоянию системы в прошлом.

Таким образом, можно восстановить поврежденные или случайно удаленные файлы, а также выяснить, кто автор внесенных в код изменений.

Другое назначение системы контроля версий — организация командной работы над проектом.

Система контроля версий в команде разработчиков позволяет корректно слить изменения от нескольких участников, не перезаписывая результаты работы друг друга.

При возникновении конфликтной ситуации, когда разработчики правят один и тот же участок кода, система обязательно просигнализирует об этом. Добавить новый код без устранения конфликта не получится.
Настройка git

Перед началом работы необходимо сообщить ​git, ​кто вы и как вас представлять другим участникам распределенной системы контроля версий. Пока вы не подпишетесь, система не даст вам регистрировать снимки проекта, коммиты.

Все ваши изменения должны быть подписаны вашим именем и электронным адресом, чтобы другие участники проекта знали, чьи это правки и как с вами связаться. Сделать это нужно один раз, как правило, сразу после установки git, если вы переустановите систему, процедуру потребуется повторить.

Чтобы задать ваши имя и электронный адрес, следует воспользоваться командой ​git config:​

git config --global user.name "John Doe"
git config --global user.email johndoe@example.com

Убедиться в том, что настройки успешно установлены, можно, запросив их список при помощи команды ​git config --list.​

Она выдает множество настроек, в том числе и только что установленные значения.

user.name=John Doe
user.email=johndoe@example.com

Файл .gitignore

Файл .gitignore для работы с проектом в IntelliJ Idea должен включать в себя следующие строчки:

.idea/
*.iml

Работа с GitHub и IntelliJ Idea

Работа с GitHub в нужном нам количестве подробно описана на видеозаписи занятия.

Документация по настройке IntelliJ Idea
Базовые понятия

    проект - каталог с файлами исходного кода (кодовая база)
    репозиторий - хранилище истории разработки проекта
    клонирование (репо) - скачивание репо на компьютер

Базовый порядок работы

    Инициализация нового репо
        git init
        создается “скрытое хранилище” - каталог .git/
    Сохранение
        Индексация файлов (добавить в очередь на сохранение)
            git add .
        Выполнить сохранение
            git commit -m 'update'
    Привязка репо
    Выгрузка ветки на GitHub
        git push -u origin main (main или другое название)
        git push (если ветку уже выгружал)

Файл README.md

    использует формат Markdown
    описание репо на GitHub
    помещается в корень проекта, как правило

Пример

## Test Project

Работа с привязкой

Удалить старую привязку

git remote rm origin

Добавить привязку

git remote add origin скопированная_ссылка

Просмотр текущей привязки

git remote -v

Ветвление в Git

    Ветка - еще одна версия проекта (изолированный поток разработки)

Untitled
Стратегии ветвления в Git

    Git Flow
        main/master/stable - long-term (только для проверенного, оттестированного кода - “священный грааль”)
        develop/current - long-term (для тестирования, текущая разработка)
        login/bugfix1/payments - short-term
    GitHub Flow
        main/master/stable - long-term
        login/bugfix1/payments - short-term

Базовые команды по работе с ветками в Git

    git branch просмотр веток
        git branch -avv подробный вывод
        выйти из просмотра - q
    git branch новая_ветка создать ветку
        git branch новая_ветка старая_ветка
    git checkout ветка переключиться на ветку
        git checkout - переключиться на предыдущую ветку
        ПЕРЕКЛЮЧАТЬСЯ НЕОБХОДИМО С “ЧИСТЫМ СТАТУСОМ”
    git checkout -b новая_ветка создать и переключиться
        git checkout -b новая_ветка старая_ветка
    git branch -D ветка удалить ветку (локально)
    git merge название_ветки слияние веток
    git push origin --delete ветка удалить ветку (дистанционную)
    git branch -m новое_название переименовать ветку (локально)

Слияние веток

    перенос (интеграция) изменений из одной ветки в другую
    выполняется командой
        git merge название_ветки
    перед слиянием необходимо переключиться в целевую ветку

Пример

git checkout -b login
# внести правки
git checkout master
git merge login
git branch -D login

Клонирование репо

    Открыть репо на GitHub
    Решить, куда его скачать
    Скопировать SSH-ссылку
    Выполнить команду
        git clone скопированная_ссылка

Ссылки

    клонирование
    ветвление
    клонирование через IDEA

Практика
1. Подготовка

Участники: TL - team leader, D1 - developer 1, D2 - developer 2 Выберете кто из вас будет тим-лидером.

    TL создаёт пустой проект на своём компьютере
    TL добавляет в проект файлы index.html и style.css
    TL создаёт репозиторий на GitHub из готового кода
    TL создаёт ветку dev
    TL добавляет D1 и D2 в collaborators
        зайти в github
        settings
        collaborators
        add collaborator
        ввести имя разработчика
        добавить
        разработчик получит письмо на почту, где ему предложат принять приглашение, после чего он сможет работать с репозиторием
    D1 и D2 клонируют репозиторий к себе на компьютер

2. Работа с ветками:

Посмотрим как происходит работа с ветками в процессе разработки. Часто вливать ветки задач в dev разрешается только через пул-реквесты. Это делается для того, чтобы контролировать качество кода. Один разработчик делает пул-реквест, а другой смотрит его код и принимает или отклоняет его.

    TL работает над содержимым сайта
        TL создаёт ветку content
        TL вносит изменения в файл index.html и style.css (только в тег main)
        TL делает коммит и пушит изменения
        TL создаёт пулл-реквест в ветку dev
        D1 или D2 принимает пулл-реквест
        TL удаляет ветку content
    D1 работает над шапкой сайта
        D1 создаёт ветку header
        D1 вносит изменения в файл index.html и style.css (только в тег header)
        D1 делает коммит и пушит изменения
        D1 создаёт пулл-реквест в ветку dev
        TL принимает пулл-реквест
        D1 удаляет ветку header
    D2 работает над футером сайта
        D2 создаёт ветку footer
        D2 вносит изменения в файл index.html и style.css (только в тег footer)
        D2 делает коммит и пушит изменения
        D2 создаёт пулл-реквест в ветку dev
        TL принимает пулл-реквест
        D2 удаляет ветку footer

3. Работа с конфликтами

Во время принятие пул-реквестов могут случиться конфликты. Тогда их решает либо тот кто делает пулл-реквест, либо тот кто его принимает.

    TL работает над содержимым сайта
        TL создаёт ветку tl-content
        TL вносит изменения в файл index.html и style.css (только в тег main)
        TL делает коммит и пушит изменения
        TL создаёт пулл-реквест в ветку dev
        D2 принимает пулл-реквест
        Ветку tl-content удалять не нужно!
    D1 работает над содержимым сайта
        D1 создаёт ветку d1-content
        D1 вносит изменения в файл index.html и style.css (только в тег main)
        D1 делает коммит и пушит изменения
        D1 создаёт пулл-реквест в ветку dev
        TL принимает пулл-реквест перед этим разрешая конфликты
        Ветку d1-content удалять не нужно!
    D2 работает над содержимым сайта
        D2 создаёт ветку d2-content
        D2 вносит изменения в файл index.html и style.css (только в тег main)
        D2 делает коммит и пушит изменения
        D2 создаёт пулл-реквест в ветку dev
        D1 принимает пулл-реквест перед этим разрешая конфликты
        Ветку d2-content удалять не нужно!

4. Актуализация веток

После того, как ветки задач вливаются dev удалять их не обязательно. Если задачи не завершены до конца то можно продолжить работу над ними в этих ветках. Время от времени необходимо вливать изменения из dev в ветки задач, чтобы они не устаревали.

Подготовительный этап, сделаем ещё несколько изменений в ветках, чтобы потом порешать конфликты:

    TL вносит изменения в dev
        TL переключается на ветку dev
        TL вносит изменения в файл index.html в тег main
        TL делает коммит и пушит изменения
    TL вносит изменения в tl-content
        TL переключается на ветку tl-content
        TL вносит изменения в файл index.html в тег main
        TL делает коммит и пушит изменения
    D1 вносит изменения в d1-content
        D1 переключается на ветку d1-content
        D1 вносит изменения в файл index.html в тег main
        D1 делает коммит и пушит изменения
    D2 вносит изменения в d2-content
        D2 переключается на ветку d2-content
        D2 вносит изменения в файл index.html в тег main
        D2 делает коммит и пушит изменения

Теперь каждый разработчик должен актуализировать свою ветку, чтобы в ней были все последние изменения из dev. Каждый работает в своей ветке (TL в tl-content, D1 в d1-content, D2 в d2-content).

    git fetch - получить информацию о новых изменениях с сервера
    git pull - обновить свою ветку с сервера
    git merge origin/dev - слить изменения из ветки dev в свою ветку
    git status - посмотреть, в каких файлах произошли конфликты
    Разрешить конфликты
        Зайти в каждый файл, в котором есть конфликты
        Разрешить конфликты (оставить только тот код, который нужен)
        Отправить изменения на сервер: git add -A, git commit -m "merge", git push
    Теперь ветка разработчика актуальна

./code/README.md
Git
git - программа

    Хранит историю всех изменений, которые были внесены в проект
    Отвечает за синхронизацию изменений между серверным и локальными репозиториями
        Помогает сливать вместе разные копии
    Позволяет откатиться на любую версию истории изменений, либо отменить один конкретный коммит

github - сервер и сайт

    Сервер, на котором можно бесплатно хранить серверные-репозитории
    Графический интерфейс для этих репозиториев
    Площадка для открытой разработки проектов (open-source)

Создание репозитория

    Создание репозитория с нуля
        Создаём репо на github
        Клонируем его к себе на компьютер через git clone {url} (нельзя создавать репо внутри другого репо)
            через ls -a можно увидеть есть ли папка .git в текущей папке
        Создаём какие-то файлы
        Отправляем новые файлы на сервер
            git add -A - говорим, что все изменения мы хотим отправить на сервер (кладём бумаги в конверт)
            git commit -m "{ваше сообщение}" - вы даёте название подготовленной пачке изменений (запечатываем конверт и пишем на нём тему)
            git push - отправляем пачку изменений на сервер (отправляем конверт по почте)
    Создание репозитория из готового кода ??????

Совместная разработка по модели fork-based

    Делаете форк репозитория на github
    Клонируете его к себе на компьютер git clone {url}
    Вносите изменения
    Отправляете изменения на сервер (см. выше: git add -A, git commit -m "{ваше сообщение}", git push)
    Делаете pull-request на github
    Владелец оригинального репозитория принимает или отклоняет ваш pull-request

Совместная разработка по модели branch-based git flow

    Создаём репозиторий
    Клонируем его на свой компьютер
    Создаём ветку dev: git checkout -b dev
    Делаем git push (отправляем ветку на сервер)
    Сделаем новую ветку для задачи "html-page"
        убедимся, что мы сейчас на ветке dev: git status
        создаём ветку git checkout -b "html-page"
        вносим изменения
        коммитим/пушим изменения на сервер (add/commit/push)
    Если хотим сделать ещё одну ветку для другой задачи
        Перейти в ветку dev git checkout dev
        создаём ветку git checkout -b "readme"
        вносим изменения
        коммитим/пушим изменения на сервер (add/commit/push)
    Теперь заливаем обе ветки в ветку dev
        Переходим в ветку dev git checkout dev
        Обновляем ветку dev с сервера git pull
        Получаем информацию с сервера о новых изменениях git fetch
        Заливаем в ветку dev изменения из html-page: git merge origin/html-page
        Удаляем ветку html-page
            локально git branch -D html-page
            дистанционно git push origin --delete html-page
        Заливаем в ветку dev изменения из readme: git merge origin/readme
            Удаляем ветку readme
        Отправляем изменения на сервер git push
    Заливаем ветку dev в main
        Переходим в ветку main git checkout main
        Обновляем ветку main с сервера git pull
        Получаем информацию с сервера о новых изменениях git fetch
        Заливаем в ветку main изменения из html-page: git merge origin/dev
        Отправляем изменения на сервер git push

Решение проблем

    Не получается запушить ветку (ошибка fatal: The current branch [имя ветки] has no upstream branch.)
        выполните git push --set-upstream origin [имя ветки]
    В терминале открывается редактор кода vim или nano
        если открылся vim :q! enter
        если открылся nano ctrl+x, ctrl+n

Сценарии использования Git

    Есть некий проект. Мы не входим в команду разработки этого проекта, но хотим поучаствовать в его развитии.
        Делаем fork (на сервер создаётся копия оригинального репозитория)
        Клонируем себе на компьютер (создаём локальный репозиторий)
        Вносим изменения
        Коммтим, пушим (отправляем изменения в нашу копию оригинального репозитория)
        Оформляем пул-реквест из копии в оригинальный репозиторий
        Разработчик либо принимает пул-реквест, либо отклоняет его
    Есть некий проект. Мы не входим в команду разработки этого проекта. Мы хотим развивать этот проект по-своему.
        Делаем fork (на сервер создаётся копия оригинального репозитория)
        Клонируем себе на компьютер (создаём локальный репозиторий)
        Вносим изменения
        Коммтим, пушим (отправляем изменения в нашу копию оригинального репозитория)

.gitignore

Если вы не хотите отправлять какой-то файл в серверный репозиторий
Откатывание изменений

    Откатиться до состояния последнего коммита
        Посмотреть какие файлы были изменены, но не закоммичены: git status
        Откатить эти изменения: git reset --hard
    Откатить конкретный коммит
        Найти номер нежелательного коммита, скопировать его
        git revert [номер коммита]
            Если возникли конфликты - решить их и git (add/commit/push)
            Если открылся редактор кода - закрыть его
                Если открылся vim :q! enter
                Если открылся nano ctrl+x, ctrl+n
                Если открылся блокнот - закрыть окно с сохранением изменений
        git push

Решение конфликтов

    Смотрим в каких файлах произошли конфликты через git status
    Переходим в эти файлы и разрешаем конфликты
    Отправляем изменения (add/commit/push)

./code/index.html

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <!-- Header -->
    <header></header>

    <!-- Content -->
    <main></main>

    <!-- Footer -->
    <footer></footer>
  </body>
</html>

./code/style.css

header {
}

main {
}

footer {
}

